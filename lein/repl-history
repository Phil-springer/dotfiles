((fn [values]
  (loop [to-process values
         result []]
    (if (empty? to-process)
      result
      (recur 
       (rest to-process) 
       (if (= (first to-process) (last result))
         result
         (conj result (first to-process)))))))
              
  [1 1 2 2 2 3 4 4])
(contains? [1 1 1] 3)
(contains? [1 1 1] 5)
(contains? [1 1 1] 1)
(contains? #{4 5 6} 4)
(contains? #{4 5 6} 1)
(contains? #{4 5 6} 4)
(contains? #{4 5 6} 5)
(contains? #{4 5 6} 6)
(contains? [ 1 1 1 1 1 ] 5)
(contains? [ 1 1 1 1 1 ] 4)
(contains? [ 1 1 1 1 1 ] 6)
((fn [values reps]
  (loop [to-process values
         remaining-reps reps
         result []]
    (if (empty? to-process)
      result
      (recur
       (if (= remaining-reps 0)
         (rest to-process)
         to-process)
       (if (= remaining-reps 0)
         reps
         (dec remaining-reps))
       (if (= remaining-reps 0)
         result
         (conj result (first to-process)))))))
         [a b c] 3)
((fn [values reps]
  (loop [to-process values
         remaining-reps reps
         result []]
    (if (empty? to-process)
      result
      (recur
       (if (= remaining-reps 0)
         (rest to-process)
         to-process)
       (if (= remaining-reps 0)
         reps
         (dec remaining-reps))
       (if (= remaining-reps 0)
         result
         (conj result (first to-process)))))))
         [1 2 3] 3)
(take 5 (iterate #(+ 3 %) 1))
(take 10 (iterate #(div % 2)))
(take 10 (iterate #(/ % 2)))
(take 10 (iterate #(\ % 2)))
(take 10 (iterate #(/ % 2) 1))
((fn [insert values]
  (loop [to-process values
          result []]
    (if (empty? to-process)
      result
      (recur
       (rest to-process)
       (conj (conj result (head to-process))) insert))))) x [1 2 3])
((fn [insert values]
  (loop [to-process values
          result []]
    (if (empty? to-process)
      result
      (recur
       (rest to-process)
       (conj (conj result (head to-process))) insert))))) 'x' [1 2 3])
((fn [insert values]
  (loop [to-process values
          result []]
    (if (empty? to-process)
      result
      (recur
       (rest to-process)
       (conj (conj result (first to-process))) insert))))) 'x' [1 2 3])
((fn [insert values]
  (loop [to-process values
          result []]
    (if (empty? to-process)
      result
      (recur
       (rest to-process)
       (conj (conj result (first to-process)) insert))))) 'x' [1 2 3])
((fn [insert values]
  (loop [to-process values
          result []]
    (if (empty? to-process)
      result
      (recur
       (rest to-process)
       (conj (conj result (first to-process)) insert))))) 0 [1 2 3])
((fn [insert values]
  (loop [[current & remainder] values
          result []]
    (if (empty? to-process)
      (conj result current)
      (recur
       remainder
       (conj (conj result current) insert))))) 0 [1 2 3])
((fn [insert values]
  (loop [[current & remainder] values
          result []]
    (if (empty? remainder)
      (conj result current)
      (recur
       remainder
       (conj (conj result current) insert))))) 0 [1 2 3])
((fn [values]
  (loop [to-process values
          current []
         result []]
    (if (empty? to-process)
      (if (empty? current)
        (conj result current)
        result)
      (let [next-value (first values)
            append-next (or (empty? current) (= next-value (first current))]
       (recur
        (rest values)
        (if append-next
          (conj current next-value)
          [])
        (if append-next
          result
((fn [values]
  (loop [to-process values
          current []
         result []]
    (if (empty? to-process)
      (if (empty? current)
        (conj result current)
        result)
      (let [next-value (first values)
            append-next (or (empty? current) (= next-value (first current)))]
       (recur
        (rest values)
        (if append-next
          (conj current next-value)
          [])
        (if append-next
          result
          (conj result current))))))) [1 1 2 2 3 3 3])
((fn [values]
  (loop [to-process values
          current []
         result []]
    (if (empty? to-process)
      (if (empty? current)
        (conj result current)
        result)
      (let [next-value (first values)
            append-next (or (empty? current) (= next-value (first current)))]
       (recur
        (rest to-process)
        (if append-next
          (conj current next-value)
          [])
        (if append-next
          result
          (conj result current))))))) [ 1 1 2 2 ])
((fn [values]
  (loop [to-process values
          current []
         result []]
    (if (empty? to-process)
      (if (empty? current)
        (conj result current)
        result)
      (let [next-value (first to-process)
            append-next (or (empty? current) (= next-value (first current)))]
       (recur
        (rest to-process)
        (if append-next
          (conj current next-value)
          [])
        (if append-next
          result
          (conj result current))))))) [ 1 1 2 2 ])
((fn [values]
  (loop [to-process values
          current []
         result []]
    (if (empty? to-process)
      (if (empty? current)
        result
        (conj result current))
      (let [next-value (first to-process)
            append-next (or (empty? current) (= next-value (first current)))]
       (recur
        (rest to-process)
        (if append-next
          (conj current next-value)
          [])
        (if append-next
          result
          (conj result current))))))) [ 1 1 2 2 ])
((fn [values]
  (loop [to-process values
          current []
         result []]
    (if (empty? to-process)
      (if (empty? current)
        result
        (conj result current))
      (let [next-value (first to-process)
            append-next (or (empty? current) (= next-value (first current)))]
       (recur
        (rest to-process)
        (if append-next
          (conj current next-value)
          [])
        (if append-next
          result
          (conj result current))))))) [ 1 1 2 1 1 1 3 3])
((fn [values]
  (loop [to-process values
          current []
         result []]
    (if (empty? to-process)
      (if (empty? current)
        result
        (conj result current))
      (let [next-value (first to-process)
            append-next (or (empty? current) (= next-value (first current)))]
       (recur
        (rest to-process)
        (if append-next
          (conj current next-value)
          [])
        (if append-next
          result
          (conj result current))))))) [])
(def boo (fn [values]
  (loop [to-process values
          current []
         result []]
    (if (empty? to-process)
      (if (empty? current)
        result
        (conj result current))
      (let [next-value (first to-process)
            append-next (or (empty? current) (= next-value (first current)))]
       (recur
        (rest to-process)
        (if append-next
          (conj current next-value)
          [])
        (if append-next
          result
          (conj result current))))))))
(boo [])
(boo [1 1])
(boo [1])
(boo [1 2])
(def boo (fn [values]
  (loop [to-process values
         current []
         result []]
    (if (empty? to-process)
      (if (empty? current)
        result
        (conj result current))
      (let [next-value (first to-process)
            append-next (or (empty? current) (= next-value (first current)))]
       (recur
        (rest to-process)
        (if append-next
          (conj current next-value)
          [next-value])
        (if append-next
          result
          (conj result current))))))))
(boo [1 2])
(boo [1 1 1 2])
(boo [1 1 1 2 2 ])
(boo [1 1 1 2 1 1 1 3 3 ])
((fn [values n]
  (loop [to-process values
         iter n
          result []]
    (if (empty? to-process)
      result
      (recur
       (rest to-process)
       (if (= iter 0)
         n
         (dec iter))
       (if (= item 0)
         result
         (conj result (first to-process))))))) [ 1 2 3 4 5] 3)
((fn [values n]
  (loop [to-process values
         iter n
          result []]
    (if (empty? to-process)
      result
      (recur
       (rest to-process)
       (if (= iter 0)
         n
         (dec iter))
       (if (= iter 0)
         result
         (conj result (first to-process))))))) [ 1 2 3 4 5] 3)
((fn [values n]
  (loop [to-process values
         iter n
          result []]
    (if (empty? to-process)
      result
      (recur
       (rest to-process)
       (if (= iter 1)
         n
         (dec iter))
       (if (= iter 1)
         result
         (conj result (first to-process))))))) [ 1 2 3 4 5] 3)
((fn [values n]
  (loop [to-process values
         iter n
          result []]
    (if (empty? to-process)
      result
      (recur
       (rest to-process)
       (if (= iter 1)
         n
         (dec iter))
       (if (= iter 1)
         result
         (conj result (first to-process))))))) [ 1 2 3 4 5 6 7 8] 3)
range
(range)
(let [a b c] (range))
(let [a b c d] (range))
(let [[a b c d]] (range))
(let [[a b c d]] (range) (println (str a b c d)))
(let [[a b c d] (range)] (println (str a b c d)))
((def [n values]
  (loop [iter n
         to-process values
         acc []]
    (if (= 0 iter)
      [acc to-process]
      (recur 
       (dec iter)
       (rest to-process)
       (conj acc (first to-process))))))
      3 [ 1 2 3 4 5])
((fn [n values]
  (loop [iter n
         to-process values
         acc []]
    (if (= 0 iter)
      [acc to-process]
      (recur 
       (dec iter)
       (rest to-process)
       (conj acc (first to-process))))))
      3 [1 2 3 4 5 6])
(vec '(1 2 3))
(let [[a b & c :as d] [1 2 3 4] [a b c d])
(let [[a b & c :as d] [1 2 3 4]] [a b c d])
(let [[a b & c :as d] [1 2 3 4 5]] [a b c d])
((fn [ & c ] c) 1 2 3)
((fn [&values]
  (loop [[current & remainder] values
         match false]
    (if (empty? remainder)
      (if (and current match)
        false
         match)
      (recur
       remainder
       (if current
         true
         false)))))
    true true)
((fn [ & values ]
  (loop [[current & remainder] values
         match false]
    (if (empty? remainder)
      (if (and current match)
        false
         match)
      (recur
       remainder
       (if current
         true
         false)))))
    true true)
(def xor (fn [ & values ]
  (loop [[current & remainder] values
         match false]
    (if (empty? remainder)
      (if (and current match)
        false
         match)
      (recur
       remainder
       (if current
         true
         false)))))
    )
(xor true)
(xor true false)
(xor false true)
(def xor (fn [ & values ]
  (loop [[current & remainder] values
         match false]
    (if (empty? remainder)
      (if (and current match)
        false
         current)
      (recur
       remainder
       current))))
    )
(xor false true)
(xor true false)
(def xor (fn [ & values ]
  (loop [[current & remainder] values
         match false]
    (if (empty? remainder)
      (if (and current match)
        false
         (or current match))
      (recur
       remainder
       (or current match)))))
    )
(xor true false)
(xor false true)
(xor false false)
(xor true true)
(xor true true true)
(xor true true false)
(xor true )
(def xor (fn [ & values ]
  (loop [[current & remainder] values
         match true]
    (if (empty? remainder)
      (if (and current match)
        false
         (or current match))
      (recur
       remainder
       (or current match)))))
    )
(xor true false)
(xor true true)
(xor true )
(xor false false)
(def xor (fn [ & values ]
  (loop [[current & remainder] values
         match current]
    (if (empty? remainder)
      (if (and current match)
        false
         (or current match))
      (recur
       remainder
       (or current match)))))
    )
(xor true)
(xor false)
(xor false true)
(xor true false )
(xor true false true)
(def xor (fn [ & values ]
  (loop [[current & remainder] values
         one-true false
         all-true true]
    (if (empty? remainder)
      (if (and current all-true)
        false
        one-true)
      (recur
       remainder
       (or current one-true)
       (and current all-true)))))
    )
(xor true)
(xor true true)
(xor true false)
(xor false false)
(xor false true false)
(xor false true false true)
